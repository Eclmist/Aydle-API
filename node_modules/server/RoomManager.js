var Room = require('server/Room');
var User = require('server/User');

// **** This class handles some socket responsibilities ****
class RoomManager{
    constructor(io){
        this.io = io;
        this.gamerooms = {};
    }

    getRoom(roomCode){
        let room = this.gamerooms[roomCode];
        return room;
    }

    createRoom(roomCode, socketObj){
        let room = new Room(roomCode);
        gamerooms[roomCode] = room;

        socketObj.currentRoom = room;
        
        return room;
    }

    joinRoom(roomCode, socketObj, userID, successCallback){
        let room = this.getRoom(roomCode);
        if(room !== undefined){
            socketObj.leaveAll();
            socketObj.join(roomCode);

            let oldPlayer = room.getUserByUserID(userID);
            if(oldPlayer !== undefined){
                let replacement = Object.assign({socketID:1,isAway:false},oldPlayer);
                replacement.isAway = false;
                replacement.socketID = socketObj.id;
                room.addUser(replacement);

                let oldSocket = this.io.sockets.connected[oldPlayer.socketID];
                if(oldSocket !== undefined){
                    oldSocket.disconnect();
                }

                room.removeUser(oldPlayer);
                successCallback(oldPlayer.name);
            } else {
                let user = new User(this.io, socketObj.id, userID, 0, '', false);
                room.addUser(user);
                successCallback('');
            }

            socketObj.currentRoom = room;

        }
    }

    UpdateLobby(room){
        let visibleRoom = this.getRoomWithVisiblePlayers(room);
        this.io.in(room.code).emit('onLobbyUpdate', visibleRoom);
    }

    getRoomWithVisiblePlayers(room){
        let visiblePlayers = [];

		for(let i = 0; i < room.players.length; i++){
			if(!room.players[i].isAway)
				visiblePlayers.push(room.players[i]);
		}

		return {
			name: room.name,
			code: room.code,
			players: visiblePlayers,
			isPlaying : room.isPlaying,
			games : room.games
		};
    }

    get LEGAL_CHARACTERS(){
        return "abcdefghijklmnopqrstuvwxyz0123456789";
    }

    generateUniqueCode(codeCount) {
    let code = "";

    for (let i = 0; i < codeCount; i++)
        code += this.LEGAL_CHARACTERS.charAt(Math.floor(Math.random() * this.LEGAL_CHARACTERS.length));

        let rooms = this.io.sockets.adapter.rooms;
        for(let room in rooms){
            if(room == code){
                return generateUniqueCode(codeCount);
            }
        } 

        return code.toUpperCase();
    }

    checkRoomIsAway(code){
        let isActive = false;
        let room = this.gamerooms[code];

        for(let i = 0; i < room.players.length; i++){
            if(!room.players[i].isAway){
                isActive = true;
                break;
            }
        }

        if(!isActive){
            delete this.gamerooms[code];
        }
    }
    
    onDisconnect(socketID){
        Object.keys(gamerooms).forEach((code) => {
            gamerooms[code].onDisconnect(socketID);
        });
    }


}
module.exports = RoomManager;