var Room = require('server/Room');
var User = require('server/User');

// Handles sockets joining and hosting rooms
// also handles the creation of users and rooms
class RoomManager{
    constructor(){
        this.io = undefined;
        this.gamerooms = {};
    }

    initHandlers(socket, io){

        if(io !== undefined){
            this.io = io;
        }

        if(socket !== undefined){

            socket.on('requestJoin', (code, playerID, successCallback) => {
                this.joinRoom(socket, code, playerID, successCallback);
            });

            socket.on('requestHost', (playerID,roomName,callback) => {
                this.hostRoom(socket, playerID, roomName, callback);
            });

            socket.on('setLobbyName', (name, callback) => {
                this.setRoomName(socket, name, callback);
            });

            socket.on('setName', (name, callback) => {
                this.setUserName(socket, name, callback);
            });

            socket.on('disconnecting', () => {
                this.onDisconnect(socket.id);
            });
        }

    }

    getRoom(roomCode){
        let room = this.gamerooms[roomCode];
        return room;
    }

    createRoom(roomCode){
        let room = new Room(roomCode);
        // store a reference to this room
        gamerooms[roomCode] = room;
        
        return room;
    }

    bindRoomToSocket(socket, room){
        socket.leaveAll();
        socket.join(room.code);
        socket.currentRoom = room;
    }

    hostRoom(socket, userID, roomName, callback){
        let generatedCode = this.generateUniqueCode(4);
        let createdRoom = this.createRoom(generatedCode);
        this.bindRoomToSocket(socket,createdRoom);
        createdRoom.name = roomName;
        let user = new User(this.io, socket.id, userID, 0, '', true);
        createdRoom.addUser(user);
        let visibleUsersRoom = this.getRoomWithVisibleUsers(createdRoom);
        callback(visibleUsersRoom);
        this.updateLobby(createdRoom);
    }

    joinRoom(socketObj, roomCode, userID, successCallback){
        let room = this.getRoom(roomCode);
        if(room !== undefined){
            this.bindRoomToSocket(socketObj, room);

            let oldPlayer = room.getUserByUserID(userID);
            if(oldPlayer !== undefined){
                let replacement = Object.assign({socketID:1,isAway:false},oldPlayer);
                replacement.isAway = false;
                replacement.socketID = socketObj.id;
                room.addUser(replacement);

                let oldSocket = this.io.sockets.connected[oldPlayer.socketID];
                if(oldSocket !== undefined){
                    oldSocket.disconnect();
                }

                room.removeUser(oldPlayer);
                successCallback(oldPlayer.name);
            } else {
                let user = new User(this.io, socketObj.id, userID, 0, '', false);
                room.addUser(user);
                successCallback('');
            }

            this.updateLobby(room);
            let user = room.getUserBySocketID(socketObj.id);
            
            if(user.isInitialized){
                this.io.in(roomCode).emit('onPeerUpdate', user);
            }      
        }
    }

    setRoomName(socket, name, callback){
        let room = socket.currentRoom;
        if(room !== undefined){
            room.name = name;
            this.updateLobby(room);
            callback(true);
        } else {
            callback(false);
        }
    }

    setUserName(socket, name, callback){
        let userThatChangedName;
        let room = socket.currentRoom;

        if(room !== undefined){
            let uniqueName = this.makeNameUnique(name, 0, room.users,socket.id);
            for(let i = 0; i < room.users.length; i++){
                if(room.users[i].socketID === socket.id){
                    room.users[i].name = uniqueName;
                    room.users[i].isInitialized = true;
                    userThatChangedName = room.users[i];
                    break;
                }
            }

            if(userThatChangedName !== undefined){
                callback(true);
                this.io.in(room.code).emit('onPeerUpdate',{
                    playerID: userThatChangedName.userID,
                    name: userThatChangedName.name,
                    isInitialized: userThatChangedName.isInitialized
                });
            } else {
                callback(false);
            }
        }
    }

    updateLobby(room){
        let visibleRoom = this.getRoomWithVisibleUsers(room);
        this.io.in(room.code).emit('onLobbyUpdate', visibleRoom);
    }

    getRoomWithVisibleUsers(room){
        let visibleUsers = [];

		for(let i = 0; i < room.users.length; i++){
			if(!room.users[i].isAway)
				visibleUsers.push(room.users[i]);
		}

		return {
			name: room.name,
			code: room.code,
			users: visibleUsers,
			isPlaying : room.isPlaying,
			games : room.games
		};
    }

    get LEGAL_CHARACTERS(){
        return "abcdefghijklmnopqrstuvwxyz0123456789";
    }

    generateUniqueCode(codeCount) {
    let code = "";

    for (let i = 0; i < codeCount; i++)
        code += this.LEGAL_CHARACTERS.charAt(Math.floor(Math.random() * this.LEGAL_CHARACTERS.length));

        let rooms = this.io.sockets.adapter.rooms;
        for(let room in rooms){
            if(room == code){
                return generateUniqueCode(codeCount);
            }
        } 

        return code.toUpperCase();
    }

    makeNameUnique(name, counter, users, excludeSocketID)
    {
        let count = counter;
        let originalName = name
        let pendingName;
        let exist = false;
                
        if( count !== 0){
            pendingName = name + " - " + count;
        } else {
            pendingName = name;
        }
            

        for(let i = 0; i < users.length; i++){
            // skip self if reconnecting as same player
            if(!users[i].isAway && users[i].socketID !== excludeSocketID){
                if(pendingName === users[i].name){
                    exist = true;
                    break;
                }
            }
        }

        if(exist === true){
            count++;
            return this.makeNameUnique(originalName, count, users, excludeSocketID);
        } else {
            if(count !== 0){
                return pendingName;
            } else {
                return originalName;
            }
        }   
    }
    
    // calls disconnect events for every room & delete in-active rooms 
    onDisconnect(socketID){
        Object.keys(this.gamerooms).forEach((code) => {
            this.gamerooms[code].onDisconnect(socketID);
            if(!this.gamerooms[code].isActive){
                delete this.gamerooms[code];
            }
        });
    }


}
module.exports = RoomManager;