var GenericGame = require('games/GenericGame');

class MonsterRaid extends GenericGame{
    constructor(){
        super();

        this.waves = [];
        this.currentWave;
        this.isBossFight = false;
        this.bossHealth = 100;
    }

    get NUMBER_OF_LANES(){
        return 3;
    }
    get NUMBER_OF_WAVES(){
        return 10;
    }
    get MAX_TIME_TO_REACT(){
        return 1.2;
    }
    get BOSS_POINTS(){
        return 10;
    }
    get MONSTER_POINTS(){
        return 5;
    }
    get PUNISH_POINTS(){
        return 5;
    }
    get REST_TIME(){
        return 0.5;
    }

    setupGameHandlers(socket,io){
        super.setupGameHandlers(socket,io);
            
        socket.on('spawn', function(callback){
            let currentPlayer = this.playerManager.getPlayerBySocketID(socket.id);
            let requestedWave = getWaveCopy(currentPlayer.gameStateObject.waveNumber);
            if(requestedWave !== undefined){
                currentPlayer.gameStateObject.waveObject = requestedWave;
                currentPlayer.gameStateObject.waveNumber++;
                callback(requestedWave);  
            } else {    
                // tell the player to chill and wait for boss
                // pass the player an empty wave
                currentPlayer.gameStateObject.isWaiting = true;
                callback([]);
            }   
        });
    
        // attack callback returns if monster is killed and the points given
        socket.on('attack', function(inputLane,callback){
            let currentPlayer = this.playerManager.getPlayerBySocketID(socket.id);
            attack(currentPlayer, inputLane, callback);
        });
    
    }

    start(){
        super.start();
        this.addGameStateObjectProperty('waveNumber', 1);
        this.addGameStateObjectProperty('waveObject', []);
        this.addGameStateObjectProperty('reactionTimer', this.MAX_TIME_TO_REACT);
        this.addGameStateObjectProperty('hasTimerStarted', false);
        this.addGameStateObjectProperty('isWaiting', false);

        this.prespawnMonsters();
    }

    update(){
        super.update();
        this.checkEndGameScenario();
        this.checkForBossEvent();
        this.handleReactionTimers();
    }

    damageCallback(player){
        this.getSocketObject(player.socketID).emit('onHit',this.PUNISH_POINTS);
    }

    startBossFight(){
        this.io.in(this.roomCodeReference).emit('boss');
    }

    notifyBossKilled(){
        this.io.in(this.roomCodeReference).emit('bossKilled');
    } 

    checkForBossEvent(){
        let canStart = true;

        for(let i = 0; i < this.playerManager.players.length; i++){
            let currentStateObject = this.playerManager.players[i].gameStateObject;
            if(!currentStateObject.isWaiting){
                canStart = false;
                break;
            }
        }

        this.isBossFight = canStart;

        if(this.isBossFight === true){
            this.startBossFight();
        }
    }
    
    handleReactionTimers(){
        for(let i = 0; i < this.playerManager.players.length; i++){

            let player = this.playerManager.players[i];
            let currentStateObject = player.gameStateObject;

            if(currentStateObject.hasTimerStarted){
                if(currentStateObject.reactionTimer <= 0){
                    this.damageCallback(player);
                    currentStateObject.reactionTimer = this.MAX_TIME_TO_REACT;
                }
                currentStateObject.reactionTimer -= this.gameLoop.deltaTime;
            }       
        }
    }
    
    prespawnMonsters(){
        for(let i = 0; i < this.NUMBER_OF_WAVES; i++){
    
            let tempWaveNumber = i+1;
    
            let numberOfMonstersToSpawn = (tempWaveNumber%2 === 0 ? Math.floor(tempWaveNumber/2) 
                : Math.floor(tempWaveNumber/2) + 1)
    
            let currentWave = this.prespawnWave(numberOfMonstersToSpawn);
            this.waves.push(currentWave);
        }
        // start with the least number of monsters first
        this.waves.reverse();
    }
    
    prespawnWave(numberOfMonsters){
        let tempWave = [];
        for(let i = 0; i < numberOfMonsters; i++){
            tempWave.push(getRandomLaneNumber(1,this.NUMBER_OF_LANES));
        }
    
        return tempWave;
    }
    
    getRandomLaneNumber(min,max){
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    getWaveCopy(waveNumber){
        if(waveNumber <= this.waves.length){
            let reference = this.waves[waveNumber-1];
            let waveCopy = reference.slice(0,reference.length);
            return waveCopy;
        }
        return undefined;
    }
    
    attack(player, inputLane, callback){
        if(this.isBossFight === false){
            this.slayNextMonsterInLane(player, inputLane, callback);
        } else {
            this.attackBoss(callback);
        } 
    }
    
    attackBoss(callback){
        this.bossHealth--;
        callback(true, this.BOSS_POINTS);
    }
    
    slayNextMonsterInLane(player, inputLane, callback){
        let playerStateObject = player.gameStateObject;
        // attack successful
        if(playerStateObject.waveObject[waveObject.length - 1] === inputLane){
            playerStateObject.waveObject.pop();
            //reset reaction time
            playerStateObject.reactionTimer = this.MAX_TIME_TO_REACT;
            callback(true, this.MONSTER_POINTS);
        } else {
            this.damageCallback(player);
            callback(false, 0);
        }
    }
    
    checkEndGameScenario(){
        if(this.bossHealth <= 0){
            this.notifyBossKilled();
            this.stopGameInstance();
        }
    }



}