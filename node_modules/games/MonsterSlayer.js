var engine = require('AydleEngine/AydleEngine');
var gameLoop = engine.GameLoop;

function MonsterSlayer(){}

let data = JSON.parse(process.argv[2]);

let socket = data.socket;
let io = data.io;

const NUMBER_OF_LANES = 3;
const NUMBER_OF_WAVES = 10;
const MAX_TIME_TO_REACT = 1.2;
const BOSS_POINTS = 10;
const MONSTER_POINTS = 5;
const REST_TIME = 0.5;
// this will store the 'monsters' represented by their lane number
let waves = [];
let currentWave;
let isBossFight = false;
let bossHealth = 100;
let hasReactionTimerStarted = false;
let reactionTime = MAX_TIME_TO_REACT;
let gameRunning = true;

gameLoop.SetPrepare(prepare);
gameLoop.SetUpdate(update);
gameLoop.Start();

function prepare(){
    prespawnMonsters();
    prepareHandlers();
    //debugMonsters();
    debugKill();
}

function update(){
    if(gameRunning){
        checkEndGameScenario();
        handleReaction();
    } else {
        process.exit(0);
    }
}

function prepareHandlers(){
    if(socket !== undefined && io !== undefined){

        // called once
        socket.on('spawn', function(){
            requestNextWave();
        });

        socket.on('attack', function(inputLane,callback){
            attack(inputLane,function(result){
                callback(result);
            })
        });

    }
}

function prespawnMonsters(){
    for(let i = 0; i < NUMBER_OF_WAVES; i++){

        let tempWaveNumber = i+1;

        let numberOfMonstersToSpawn = (tempWaveNumber%2 === 0 ? Math.floor(tempWaveNumber/2) 
            : Math.floor(tempWaveNumber/2) + 1)

        let currentWave = prespawnWave(numberOfMonstersToSpawn);
        waves.push(currentWave);
    }

    // start with the least number of monsters first
    waves.reverse();
}


function prespawnWave(numberOfMonsters){
    let tempWave = [];
    for(let i = 0; i < numberOfMonsters; i++){
        tempWave.push(getRandomLaneNumber(1,NUMBER_OF_LANES));
    }

    return tempWave;
}

function getRandomLaneNumber(min,max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function requestNextWave(){
    if(waves.length < 1){
        bossFight();
    } else {
        currentWave = waves.pop();
        setTimeout(sendWave,REST_TIME * 1000);
    }
}

function bossFight(){
    isBossFight = true
    socket.emit('boss');
}

function attack(lane,callback){
    if(!isBossFight){
        trySlayLane(lane,callback);
    } else {
        attackBoss(callback);
    } 
}

function attackBoss(callback){
    bossHealth--;
    socket.currentRoom.GetPlayerBySocketID(socket.id).score += BOSS_POINTS;
    callback(true);
}

function trySlayLane(lane,callback){
    // attack successful
    if(currentWave[currentWave.length - 1] === lane){
        currentWave.pop();
        //reset reaction time
        reactionTime = MAX_TIME_TO_REACT;
        onSlay();
        console.log('wave ' + waves.length);
        callback(true);
    } else {
        punishPlayer();
        callback(false);
    }

}

function onSlay(){
    // set the next wave
    if(currentWave.length < 1){
        hasReactionTimerStarted = false;
        requestNextWave();
    }
}

function sendWave(){
    socket.emit('newWave',currentWave);
    reactionTime = MAX_TIME_TO_REACT;
    hasReactionTimerStarted = true;
}

function handleReaction(){
    if(hasReactionTimerStarted){
        if(currentWave.length !== 0){
            reactionTime -= gameLoop.GetDeltaTime();

            if(reactionTime <= 0){
                punishPlayer();   
                reactionTime = MAX_TIME_TO_REACT;
            }
        }
    }
}

function punishPlayer(){
    // TODO : deduct points
    console.log('ouch');
    socket.currentRoom.GetPlayerBySocketID(socket.id).score -= 5;

}

function checkEndGameScenario(){
    if(bossHealth <= 0){
        //io.in(socket.currentRoom.code).emit('bossKilled');
        gameRunning = false;
    }
}

function debugKill(){
    //requestNextWave();
    //trySlayLane(currentWave[currentWave.length-1],function(sdfsdf){console.log('trying')});
    
}

// for debug purposes
function debugMonsters(){
    for(let i = 0; i < waves[9].length; i++){
        console.log(waves[9][i]);
    }

}
