
var engine = require('AydleEngine/AydleEngine');
var gameLoop = engine.GameLoop;

const NUMBER_OF_LANES = 3;
const NUMBER_OF_WAVES = 10;
const MAX_TIME_TO_REACT = 1.2;
const BOSS_POINTS = 10;
const MONSTER_POINTS = 5;
const REST_TIME = 0.5;

let io;
let roomCodeReference;
// this will store the 'monsters' represented by their lane number
let waves = [];
let currentWave;
let isBossFight = false;
let bossHealth = 100;
let hasReactionTimerStarted = false;
let reactionTime = MAX_TIME_TO_REACT;
let gameRunning = false;
let playerStateObjectList = [];

let playerStateObject = {
    waveNumber : 1,
    waveObject : [],
    reactionTimer : MAX_TIME_TO_REACT
};


// the only place for socket references
process.on('message', (data) => {
    
    if(data.socket !== undefined && data.io !== undefined){
        io = data.io;
        let socket = data.socket;
        roomCodeReference = socket.currentRoom.code;

        // attach a temporary object to the socket
        if(socket.playerStateObject === undefined){
            socket.playerStateObject = playerStateObject;
            playerStateObjectList.push(playerStateObject);
        }
        

        socket.on('spawn', function(callback){
            //requestNextWave();
            let requestedWave = getWaveCopy(socket.playerStateObject.waveNumber);
            socket.playerStateObject.waveObject = requestedWave;
            socket.playerStateObject.waveNumber++;
            callback(requestedWave);
            
            
        });

        socket.on('attack', function(inputLane,callback){
            attack(socket.playerStateObject, inputLane, function(result){
                callback(result);
            })
            //debug
            

        });

        // other functions that require the socket reference
        function damageCallback(){
            socket.emit('onHit');
        }


    }

    if(data.isRunning !== undefined){
        gameRunning = data.isRunning;
    }

    if(gameLoop.getHasStarted() === false){
        gameLoop.setPrepare(prepare);
        gameLoop.setUpdate(update);
        gameLoop.start();
    }
    

    function prepare(){
        prespawnMonsters();
        //debugMonsters();
        debugKill();
    }
    
    function update(){
        if(gameRunning){
            checkEndGameScenario();
        }
    }
    
    function handleTimers(){
        for(let i = 0; i < playerStateObjectList.length; i++){
            playerStateObjectList[i].reactionTimer -= gameLoop.GetDeltaTime();
        }
    }
    
    function prespawnMonsters(){
        for(let i = 0; i < NUMBER_OF_WAVES; i++){
    
            let tempWaveNumber = i+1;
    
            let numberOfMonstersToSpawn = (tempWaveNumber%2 === 0 ? Math.floor(tempWaveNumber/2) 
                : Math.floor(tempWaveNumber/2) + 1)
    
            let currentWave = prespawnWave(numberOfMonstersToSpawn);
            waves.push(currentWave);
        }
    
        // start with the least number of monsters first
        waves.reverse();
    }
    
    
    function prespawnWave(numberOfMonsters){
        let tempWave = [];
        for(let i = 0; i < numberOfMonsters; i++){
            tempWave.push(getRandomLaneNumber(1,NUMBER_OF_LANES));
        }
    
        return tempWave;
    }
    
    function getRandomLaneNumber(min,max){
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    function getWaveCopy(waveNumber){
        if(waveNumber <= waves.length){
            let reference = waves[waveNumber-1];
            let waveCopy = reference.slice(0,reference.length);
            return waveCopy;
        }
    
        return undefined;
    }
    
    function requestNextWave(socket){
        if(waves.length < 1){
            bossFight(socket);
        } else {
            currentWave = waves.pop();
            sendWave(socket);
        }
    }
    
    function bossFight(socket){
        isBossFight = true
        socket.emit('boss');
    }
    
    function attack(playerStateObject, inputLane, callback){
        if(!isBossFight){
            slayNextMonsterInLane(playerStateObject, inputLane, callback);
        } else {
            attackBoss(callback);
        } 
    }
    
    function attackBoss(callback){
        bossHealth--;
        socket.currentRoom.GetPlayerBySocketID(socket.id).score += BOSS_POINTS;
        callback(true);
    }
    
    function slayNextMonsterInLane(playerStateObject, inputLane, callback){
        // attack successful
        if(playerStateObject.waveObject[waveObject.length - 1] === inputLane){
            playerStateObject.waveObject.pop();
            //reset reaction time
            playerStateObject = MAX_TIME_TO_REACT;
            onSlay(socket);
            console.log('wave ' + waves.length);
            callback(true);
        } else {
            punishPlayer(socket);
            callback(false);
        }
    
    }
    
    function onSlay(socket){
        // set the next wave
        if(currentWave.length < 1){
            hasReactionTimerStarted = false;
            requestNextWave(socket);
        }
    }
    
    function sendWave(socket){
        socket.emit('newWave',currentWave);
        reactionTime = MAX_TIME_TO_REACT;
        hasReactionTimerStarted = true;
    }
    
    function handleReaction(){
        if(hasReactionTimerStarted){
            if(currentWave.length !== 0){
                reactionTime -= gameLoop.GetDeltaTime();
    
                if(reactionTime <= 0){
                    punishPlayer();   
                    reactionTime = MAX_TIME_TO_REACT;
                }
            }
        }
    }
    
    function punishPlayer(socket){
        // TODO : deduct points
        console.log('ouch');
        socket.currentRoom.GetPlayerBySocketID(socket.id).score -= 5;
    
    }
    
    function checkEndGameScenario(){
        if(bossHealth <= 0){
            //io.in(socket.currentRoom.code).emit('bossKilled');
            gameRunning = false;
            process.exit(0);
        }
    }





  });




function debugKill(){
    //requestNextWave();
    //trySlayLane(currentWave[currentWave.length-1],function(sdfsdf){console.log('trying')});
    
}

// for debug purposes
function debugMonsters(){
    for(let i = 0; i < waves[9].length; i++){
        console.log(waves[9][i]);
    }

}
