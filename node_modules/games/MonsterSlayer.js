
var engine = require('AydleEngine/AydleEngine');
var gameLoop = engine.GameLoop;

const NUMBER_OF_LANES = 3;
const NUMBER_OF_WAVES = 10;
const MAX_TIME_TO_REACT = 1.2;
const BOSS_POINTS = 10;
const MONSTER_POINTS = 5;
const REST_TIME = 0.5;

let io;
// this will store the 'monsters' represented by their lane number
let waves = [];
let currentWave;
let isBossFight = false;
let bossHealth = 100;
let hasReactionTimerStarted = false;
let reactionTime = MAX_TIME_TO_REACT;
let gameRunning = false;

gameLoop.SetPrepare(prepare);
gameLoop.SetUpdate(update);
gameLoop.Start();

process.on('message', (data) => {
    
    if(data.socket !== undefined && data.io !== undefined){
        io = data.io;
        let socket = data.socket;

        socket.on('spawn', function(){
            requestNextWave(socket);
        });

        socket.on('attack', function(inputLane,callback){
            attack(socket,inputLane,function(result){
                callback(result);
            })
        });
    }

    if(data.isRunning !== undefined){
        gameRunning = data.isRunning;
    }

  });


function prepare(){
    prespawnMonsters();
    //debugMonsters();
    debugKill();
}

function update(){
    if(gameRunning){
        checkEndGameScenario();
        handleReaction();
    }
}

function prespawnMonsters(){
    for(let i = 0; i < NUMBER_OF_WAVES; i++){

        let tempWaveNumber = i+1;

        let numberOfMonstersToSpawn = (tempWaveNumber%2 === 0 ? Math.floor(tempWaveNumber/2) 
            : Math.floor(tempWaveNumber/2) + 1)

        let currentWave = prespawnWave(numberOfMonstersToSpawn);
        waves.push(currentWave);
    }

    // start with the least number of monsters first
    waves.reverse();
}


function prespawnWave(numberOfMonsters){
    let tempWave = [];
    for(let i = 0; i < numberOfMonsters; i++){
        tempWave.push(getRandomLaneNumber(1,NUMBER_OF_LANES));
    }

    return tempWave;
}

function getRandomLaneNumber(min,max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function requestNextWave(socket){
    if(waves.length < 1){
        bossFight(socket);
    } else {
        currentWave = waves.pop();
        sendWave(socket);
    }
}

function bossFight(socket){
    isBossFight = true
    socket.emit('boss');
}

function attack(socket, lane, callback){
    if(!isBossFight){
        trySlayLane(socket, lane, callback);
    } else {
        attackBoss(socket, callback);
    } 
}

function attackBoss(callback){
    bossHealth--;
    socket.currentRoom.GetPlayerBySocketID(socket.id).score += BOSS_POINTS;
    callback(true);
}

function trySlayLane(socket, lane, callback){
    // attack successful
    if(currentWave[currentWave.length - 1] === lane){
        currentWave.pop();
        //reset reaction time
        reactionTime = MAX_TIME_TO_REACT;
        onSlay(socket);
        console.log('wave ' + waves.length);
        callback(true);
    } else {
        punishPlayer(socket);
        callback(false);
    }

}

function onSlay(socket){
    // set the next wave
    if(currentWave.length < 1){
        hasReactionTimerStarted = false;
        requestNextWave(socket);
    }
}

function sendWave(socket){
    socket.emit('newWave',currentWave);
    reactionTime = MAX_TIME_TO_REACT;
    hasReactionTimerStarted = true;
}

function handleReaction(){
    if(hasReactionTimerStarted){
        if(currentWave.length !== 0){
            reactionTime -= gameLoop.GetDeltaTime();

            if(reactionTime <= 0){
                punishPlayer();   
                reactionTime = MAX_TIME_TO_REACT;
            }
        }
    }
}

function punishPlayer(socket){
    // TODO : deduct points
    console.log('ouch');
    socket.currentRoom.GetPlayerBySocketID(socket.id).score -= 5;

}

function checkEndGameScenario(){
    if(bossHealth <= 0){
        //io.in(socket.currentRoom.code).emit('bossKilled');
        gameRunning = false;
        process.exit(0);
    }
}

function debugKill(){
    //requestNextWave();
    //trySlayLane(currentWave[currentWave.length-1],function(sdfsdf){console.log('trying')});
    
}

// for debug purposes
function debugMonsters(){
    for(let i = 0; i < waves[9].length; i++){
        console.log(waves[9][i]);
    }

}
