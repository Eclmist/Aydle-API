
var engine = require('AydleEngine/AydleEngine');
var gameLoop = engine.GameLoop;

const NUMBER_OF_LANES = 3;
const NUMBER_OF_WAVES = 10;
const MAX_TIME_TO_REACT = 1.2;
const BOSS_POINTS = 10;
const MONSTER_POINTS = 5;
const PUNISH_POINTS = 5;
const REST_TIME = 0.5;

let io;
let roomCodeReference;
// this will store the 'monsters' represented by their lane number
let waves = [];
let currentWave;
let isBossFight = false;
let bossHealth = 100;
let hasReactionTimerStarted = false;
let reactionTime = MAX_TIME_TO_REACT;
let gameRunning = false;
let playerStateObjectList = [];

let playerStateObject = {
    waveNumber : 1,
    waveObject : [],
    reactionTimer : MAX_TIME_TO_REACT,
    hasTimerStarted : false,
    isWaiting : false
};


// the only place for socket references
process.on('message', (data) => {
    
    io = data.io;
    let socket = data.socket;
    roomCodeReference = socket.currentRoom.code;

    // attach a temporary object to the socket
    if(socket.playerStateObject === undefined){
        socket.playerStateObject = playerStateObject;
        playerStateObjectList.push(playerStateObject);
    }
        
    socket.on('spawn', function(callback){
        let requestedWave = getWaveCopy(socket.playerStateObject.waveNumber);
        if(requestedWave !== undefined){
            socket.playerStateObject.waveObject = requestedWave;
            socket.playerStateObject.waveNumber++;
            callback(requestedWave);  
        } else {    
            // tell the player to chill and wait for boss
            // pass the player an empty wave
            socket.playerStateObject.isWaiting = true;
            callback([]);
        }   
    });

    // attack callback returns if monster is killed and the points given
    socket.on('attack', function(inputLane,callback){
        attack(socket.playerStateObject, inputLane, callback);
    });

    // other functions that require the socket reference

    function damageCallback(){
        socket.emit('onHit', PUNISH_POINTS);
    }

    function startBossFight(){
        io.in(socket.currentRoom.code).emit('boss');
    }

    function notifyBossKilled(){
        io.in(socket.currentRoom.code).emit('bossKilled');
    }

    if(data.isRunning !== undefined){
        gameRunning = data.isRunning;
    }

    if(gameLoop.getHasStarted() === false){
        gameLoop.setPrepare(prepare);
        gameLoop.setUpdate(update);
        gameLoop.start();
    }
    

    function prepare(){
        prespawnMonsters();
        //debugMonsters();
        debugKill();
    }
    
    function update(){
        if(gameRunning){
            checkEndGameScenario();
            checkForBossEvent();
            handleReactionTimers();
        }
    }

    function checkForBossEvent(){

        let canStart = true;

        for(let i = 0; i < playerStateObjectList.length; i++){
            if(!playerStateObjectList[i].isWaiting){
                canStart = false;
                break;
            }
        }

        isBossFight = canStart;

        if(isBossFight){
            startBossFight();
        }
    }
    
    function handleReactionTimers(){
        for(let i = 0; i < playerStateObjectList.length; i++){

            let currentStateObject = playerStateObjectList[i];

            if(currentStateObject.hasTimerStarted){
                if(currentStateObject.reactionTimer <= 0){
                    damageCallback();
                    currentStateObject.reactionTimer = MAX_TIME_TO_REACT;
                }
                currentStateObject.reactionTimer -= gameLoop.GetDeltaTime();
            }       
        }
    }
    
    function prespawnMonsters(){
        for(let i = 0; i < NUMBER_OF_WAVES; i++){
    
            let tempWaveNumber = i+1;
    
            let numberOfMonstersToSpawn = (tempWaveNumber%2 === 0 ? Math.floor(tempWaveNumber/2) 
                : Math.floor(tempWaveNumber/2) + 1)
    
            let currentWave = prespawnWave(numberOfMonstersToSpawn);
            waves.push(currentWave);
        }
        // start with the least number of monsters first
        waves.reverse();
    }
    
    function prespawnWave(numberOfMonsters){
        let tempWave = [];
        for(let i = 0; i < numberOfMonsters; i++){
            tempWave.push(getRandomLaneNumber(1,NUMBER_OF_LANES));
        }
    
        return tempWave;
    }
    
    function getRandomLaneNumber(min,max){
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    function getWaveCopy(waveNumber){
        if(waveNumber <= waves.length){
            let reference = waves[waveNumber-1];
            let waveCopy = reference.slice(0,reference.length);
            return waveCopy;
        }
        return undefined;
    }
    
    function attack(playerStateObject, inputLane, callback){
        if(!isBossFight){
            slayNextMonsterInLane(playerStateObject, inputLane, callback);
        } else {
            attackBoss(callback);
        } 
    }
    
    function attackBoss(callback){
        bossHealth--;
        callback(true, BOSS_POINTS);
    }
    
    function slayNextMonsterInLane(playerStateObject, inputLane, callback){
        // attack successful
        if(playerStateObject.waveObject[waveObject.length - 1] === inputLane){
            playerStateObject.waveObject.pop();
            //reset reaction time
            playerStateObject.reactionTimer = MAX_TIME_TO_REACT;
            callback(true, MONSTER_POINTS);
        } else {
            damageCallback();
            callback(false, 0);
        }
    }
    
    function checkEndGameScenario(){
        if(bossHealth <= 0){
            notifyBossKilled();
            gameRunning = false;
            process.exit(0);
        }
    }
  });
